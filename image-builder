#!/usr/bin/env bash
#
# image-builder
#
# Creates, modifies or writes GPT/EFI disk images
# consisting of an ESP and a root filesystem
#
# Kernel and userland are either build locally or downloaded
#
# © 2022 Björn Busse (see also: LICENSE)
# bj.rn@baerlin.eu
#
# Dependencies:
#
#  [Linux]
#  - ansible    [ansible]
#  - bootctl    [systemd-boot]
#  - dd         (coreutils)
#  - fdisk      (util-linux)
#  - losetup    (util-linux)
#  - mkfs.xfs   (xfsprogs)
#
# TODO:
#   Use a proper language
#   Use install instead of cp where appropriate
#   Consider support for cloud-init
#
#   Alpine:
#     Use GPT as with Gentoo/FreeBSD
#
#   FreeBSD:
#     Build NanoBSD edition
#
#   Gentoo:
#     Check stage3 checksum
#     Check binpkgs checksum
#     Support A/B partitioning scheme as with Alpine
#
#    Make sure /etc/machine-id and /etc/os-release exist
#    Check for and handle more errors
#

set -eo pipefail

SCRIPT_NAME=$(basename "$0")
SCRIPT_PATH="$(dirname -- "${BASH_SOURCE[0]}")"
SCRIPT_PATH="$(cd -- "${SCRIPT_PATH}" && pwd)"

target_arch="aarch64"
platform="pine64"

# Kernel
kernel_src_url="https://github.com/torvalds/linux"
kernel_version="6.1.0-rc8"
kernel_repo_url="https://github.com/bbusse/linux-build/releases/download/latest"
kernel="bzImage-${kernel_version}"
kernel_url="${kernel_repo_url}/${kernel}"
kernel_csum_file="${kernel}.sha384"
kernel_csum_url="${kernel_repo_url}/${kernel_csum_file}"
kernel_config_url="https://raw.githubusercontent.com/bbusse/config-kernel/main"

# Alma
alma_version="9.1"
alma_repo_url="https://mirror.rackspeed.de/almalinux/$alma_version/isos/${target_arch}"
alma_img_file="AlmaLinux-9.1-${target_arch}-minimal.iso"
alma_img_url="${alma_repo_url}/${alma_img_file}"
alma_csum_file="CHECKSUM"
alma_csum_url="${alma_repo_url}/${alma_csum_file}"

# Alpine
alpine_version=latest
alpine_compressed_img_file="${img_file}".xz
alpine_repo_url="https://github.com/OpsBoost/iss-image-build/releases/download"
alpine_config_url="https://github.com/bbusse/alpine-config"
alpine_img_url="${alpine_repo_url}/${alpine_version}/${alpine_compressed_img_file}"
alpine_csum_file="${alpine_compressed_img_file}".sha384
alpine_csum_url="${alpine_repo_url}/${alpine_version}/${alpine_csum_file}"

# Gentoo
gentoo_stage3_version="20221122T220204Z"
gentoo_stage3_file="stage3-${target_arch}-systemd-${gentoo_stage3_version}.tar.xz"
gentoo_stage3_repo_url="https://bouncer.gentoo.org/fetch/root/all/releases/amd64/autobuilds"
gentoo_stage3_url="${gentoo_stage3_repo_url}/${gentoo_stage3_version}/${gentoo_stage3_file}"
gentoo_stage3_csum_file="${gentoo_stage3_file}.sha256"
gentoo_stage3_csum_url="${gentoo_stage3_repo_url}/${gentoo_stage3_version}/${gentoo_stage3_csum_file}"
gentoo_config_url="https://github.com/bbusse/gentoo-config"
gentoo_build_container_url="https://github.com/bbusse/gentoo-build"

# FreeBSD
freebsd_source_url="https://github.com/freebsd/freebsd-src"
freebsd_config_url="https://github.com/bbusse/freebsd-config"

# OpenWrt
openwrt_source_url="https://github.com/bbusse/openwrt"
openwrt_config_url="https://github.com/bbusse/openwrt-config"

# Podman
ubuntu_version="22.04"
podman_repo_key_url="https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/unstable/xUbuntu_${ubuntu_version}/Release.key"
podman_repo_url="https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/unstable/xUbuntu_${ubuntu_version}"

log_level=info


check_root() {
    if [ -z ${SUDO_USER+x} ]; then
        if [ $UID != "0" ]; then
            printf "\n"
            error "$(printf "root privileges are needed\n")"
            printf "\n"
            exit 1
        fi
    fi
}

trim() {
    local var
    var="$*"
    # Remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    # Remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"
    var="$(echo "${var}" | tr -d '\n')"
    printf "%s" "${var}"
}

compare_checksums() {
    local file
    file="${1}"
    local csum_1
    local csum_2
    csum_1=$(cat "${file}")
    csum_1=${csum_1:0:64}
    local os
    os=$(uname)

    case "$os" in
    Linux)
        csum_2=$(sha384sum "${2}")
        csum_2=${csum_2:0:64}
        ;;
    Darwin)
        ;&
    FreeBSD)
        csum_2=$(sha384 "${2}")
        ;;
    esac

    info "$(printf "Comparing checksums\nA: %s\nB: %s\n" "${csum_1}" "${csum_2}")"

    if [ -z ${csum_1+x} ]; then
        echo 1
    fi

    if [ -z ${csum_2+x} ]; then
        echo 1
    fi

    if [ "$csum_1" == "$csum_2" ]; then
        echo 0
    else
        echo 1
    fi
}

mount_disk_image_part_by_no() {
    local disk_file
    disk_file="${1}"
    local mnt_path
    mnt_path="${2}"
    local part_no
    part_no="${3}"
    local part_fs
    part_fs="${4}"
    local loop_no
    loop_no="0"
    local dev
    dev="/dev/loop${loop_no}p${part_no}"

    # Create loop mount device
    loop_mount "${disk_file}"

    mkdir -p "${mnt_path}"

    part_fs="$(trim "${part_fs}")"

    # Mount
    if mount -t "${part_fs}" "${dev}" "${mnt_path}"; then
        info "$(printf "Mounted %s at %s\n" "${disk_file}" "${mnt_path}")"
    else
        error "$(printf "Failed to mount %s (%s) at %s \
                         Aborting..\n" "${dev}" \
                                       "${part_fs}" \
                                       "${mnt_path}")"
        # Remove disk
        loop_unmount ""
        exit 1
    fi

    # Remove disk
    loop_unmount ""
}

# TODO: Use a list of files with source/target
add_files() {
    if [ -f "${1}" ]; then
        cp "${1}" "${2}"
    fi
}

# Download if checksum differs
# from the one supplied by URL
download_miss() {
    local download_path
    download_path="${1}"
    local file
    file="${2}"
    local csum_url
    csum_url="${3}"
    local csum_file
    csum_file="${4}"
    local download_image
    download_image=1

    cd "${download_path}" || exit 1

    debug "$(printf "Fetching file checksum\n")"
    download "${csum_url}" "${download_path}"

    if [ -f "${download_path}/${file}" ]; then
        ret=$(compare_checksums "${download_path}/${csum_file}" \
                                "${download_path}/${file}")

        if [ "$ret" != "0" ]; then
            info "$(printf "Remote and local images differ\n")"
        else
            info "$(printf "Skipping download: Image exists\n")"
            download_image=0
        fi
    fi

    if [ 1 == "$download_image" ]; then
        download "${file}" "${download_path}"
    fi
}

download() {
    local url
    url="${1}"
    local path
    path="${2}"

    info "$(printf "Fetching: %s\n" "${url}")"
    # --output-dir needs a new enough cURL
    cd "${path}" || exit 1
    if ! curl -s -S --fail -LO "${url}"; then
        error "$(printf "Failed to fetch file. Aborting..\n")"
        exit 1
    fi
}

create_user() {
    local user
    user="${1}"
    local path
    path="${2}"
    local os
    os=sys_os

    case "$os" in
    freebsd)
        cmd="pw user add ${user}"
        ;;
    debian)
        ;&
    ubuntu)
        ;&
    fedora)
        cmd="adduser -U ${user} ${user}"
        ;;
    esac

    chroot "${mnt_path}" /bin/sh -c "${cmd}"
}

# Resolve a username to id in a chroot
chroot_user_id() {
    local path
    path="${1}"
    local user
    user="${2}"

    local uid
    uid="$(awk -F':' '{/'"${user}"'/ print $3 }' "${path}"/etc/passwd)"
    echo "${uid}"
}

# Add an ssh pubkey
# Use a different root if path and uid are provided
ssh_add_pubkey() {
    local user
    user="${1}"
    local key
    key="${2}"
    local path
    path="${3}/home/${user}"
    local uid
    uid="${4}"

    mkdir -p "${path}"/.ssh/
    printf "%s" "${key}" > "${path}/.ssh/authorized_keys"
    chmod 0700 "${path}"/.ssh
    chmod 0600 "${path}"/.ssh/authorized_keys

    # Use uid when working on a different root (chroot)
    # because user mapping to uid can not work
    if [ -n "${uid}" ]; then
        chown -R "${uid}":"${uid}" "${path}"
    else
        chown -R "${user}":"${user}" "${path}"
    fi
}

sway_configure_payload() {
    local user
    user="${1}"

    mkdir -p "${mnt_path}/etc/sway/config.d"

    # Overwrite existing file, then append
    printf "exec %s\n" "pip install --user -r /home/${user}/requirements.txt" > "${mnt_path}/etc/sway/config.d/exec-payload"
    printf "exec %s\n" "${PAYLOAD}" >> "${mnt_path}"/etc/sway/config.d/exec-payload
}

wifi_enable() {
    # Remove symlink (Alpine)
    if [ -f "${mnt_path}/etc/network/interfaces" ]; then
        rm "${mnt_path}/etc/network/interfaces"
        printf "\nauto wlan0\niface wlan0 inet dhcp" > "${mnt_path}/etc/network/interfaces"

        # We need to fix service ordering, wpa_supplicant starts
        # before the device exists and exits otherwise (Alpine with OpenRC)
        printf "\nrc_need=\"modules\"" >> "${mnt_path}/etc/conf.d/wpa_supplicant"
        printf "\nrc_need=\"wpa_supplicant\"" >> "${mnt_path}/etc/conf.d/udhcpd"
    fi
}

# There is no netcat or socat in Gentoo's stage3
# so we use Python to signal readiness to the host
write_booted_script() {
    local mnt_path
    mnt_path="${1}"
    local path
    path="${mnt_path}/usr/local/bin"

cat <<EOF > "${path}/booted"
#!/usr/bin/env python

import os
import socket
import sys

def signal_readiness(ip, port):
        s = socket.socket()

        try:
            s.settimeout(3)
            s.connect((ip,port))
        except socket.error as msg:
            s.close()
            print("Could not open {}:{} {}".format(ip, port, msg))
            return(1)
        else:
            s.close()
            print("{}:{} is up".format(ip, port))
            return(0)

host = os.environ.get('SUPERVISE_HOST')
port = os.environ.get('SUPERVISE_PORT')

if not host:
    print("You need to provide the address of the supervising host via SUPERVISE_HOST.\nAborting..")
    sys.exit(1)

if not port:
    print("You need to provide the port of the supervising host via SUPERVISE_PORT.\nAborting..")
    sys.exit(1)

signal_readiness(host, int(port))
EOF

    chmod +x "${path}/booted"
}

write_booted_service() {
    local mnt_path
    mnt_path="${1}"
    local host
    host="${2}"
    local path
    path="${mnt_path}/etc/systemd/system"

cat <<EOF > "${path}/booted.service"
[Unit]
Description=Signal readiness to host
After=net-config.service

[Service]
Type=oneshot
Environment=SUPERVISE_HOST=${host}
Environment=SUPERVISE_PORT=${port}
ExecStart=sleep 5
ExecStart=/usr/local/bin/booted

[Install]
WantedBy=getty.target
EOF

    ln -s -f "${path}/booted.service" "${path}/getty.target.wants/booted.service"
}

# Write systemd-unit for static network config
# for initial provisioning
# Needs iproute2
write_net_config() {
    local mnt_path
    mnt_path="${1}"
    local net_device
    net_device="${2}"
    local net_address
    net_address="${3}"
    local net_gateway
    net_gateway="${4}"
    local path
    path="${mnt_path}/etc/systemd/system"

# The interface gets renamed by systemd-udevd during boot
# We need to wait for the actual name and use a path unit to this
cat <<EOF > "${path}/net-interface.path"
[Unit]
Description=Monitor network interface

[Path]
PathChanged=/sys/class/net/enp0s1
Unit=net-config.service

[Install]
WantedBy=getty.target
EOF

cat <<EOF > "${path}/net-config.service"
[Unit]
Description=Static Network Configuration

[Install]
WantedBy=network.target

[Service]
Type=oneshot
# Hack: The path condition does not work as intended yet
ExecStart=/bin/sleep 3
ExecStart=/bin/ip link set dev ${net_device} up
ExecStart=/bin/ip addr add ${net_address} dev ${net_device}
ExecStart=/bin/ip route add default via ${net_gateway}
EOF

    # Enable service
    ln -s -f "${path}/net-config.service" "${path}/getty.target.wants/net-config.service"
    ln -s -f "${path}/net-interface.path" "${path}/getty.target.wants/net-config.path"
}

# Write config for wpa_supplicant
write_wpa_supplicant_config() {
    local mnt_path
    mnt_path="${1}"

    if [ -f wpa_supplicant.conf  ]; then
        info "$(printf "Found wifi config, copying..\n")"
        cp wpa_supplicant.conf "${mnt_path}"/etc/wpa_supplicant/
        return
    elif [ -z ${2+x} ]; then
        info "$(printf "Wifi credentials missing. ")"
        info "$(printf "Not writing a wifi config\n")"
        return
    fi

    local path
    path="${mnt_path}/etc/wpa_supplicant"
    mkdir -p "${path}"

cat <<EOF > "${path}/wpa_supplicant.conf"
ap_scan=1
autoscan=periodic:10
disable_scan_offload=1

network={
    ssid="${3}"
    key_mgmt=${2}
    psk="${4}"
}
EOF
}

info_n() {
    info_with_notify "$@"
}

info_with_notify() {
    info "$@"
    if $SEND_NOTIFICATION; then
        if ! notify-send "$1"; then
            error "$(printf "Failed to send notification\n")"
        fi
    fi
}

info() {
    if [ "info" == "${log_level}" ]; then
        echo "$@" >&2
        logger -p user.notice -t "$SCRIPT_NAME" "$@"
    fi
}

debug() {
    if [ 1 == "${DEBUG}" ]; then
        echo "$@" >&2
        logger -p user.error -t "$SCRIPT_NAME" "$@"
    fi
}

error() {
    echo -e "\033[0;31m${*}\033[0m" >&2
    logger -p user.error -t "$SCRIPT_NAME" "$@"
}

create_boot_entry() {
    local rootfs_dev
    rootfs_dev="${1}"
    local entry_file
    entry_file="${2}"
    local title
    title="${3}"

cat << EOF > "${entry_file}"
title         ${title}
linux         /bzImage
options       root=${rootfs_dev} init=/lib/systemd/systemd enforcing=1
EOF
}

create_disk() {
    local file_disk
    file_disk="${1}"

    info "$(printf "Creating disk file %s..\n" "${file_disk}")"
    dd if=/dev/zero of="${file_disk}" bs=1M count=8192 status=progress


    case "$os" in
    fedora)
        # Create partition layout
        parted "${file_disk}" mklabel gpt
        parted "${file_disk}" mkpart fat32 1 2
        parted "${file_disk}" mkpart fat32 3 259
        parted "${file_disk}" mkpart xfs 260 8GB
        parted "${file_disk}" set 2 boot on
        parted "${file_disk}" print
        ;;
    freebsd)
        loop_mount_freebsd "${file_disk}"
        gpart create -s gpt /dev/md99
        gpart add -t efi -s 512m -l efi0 /dev/md99
        gpart add -t linux-data -l rootfs0 /dev/md99
        loop_unmount_freebsd 99
        ;;
    esac
}

loop_exists() {
    local loop_dev
    loop_dev="$(losetup -f)"

    if [ "/dev/loop0" == "${loop_dev}" ]; then
        echo 0
    else
        echo 1
    fi
}

# Returns the last created loop device
# or 1 if none exists
loop_device() {
    local loop_dev

    loop_dev="$(losetup -f)"

    if [ "/dev/loop0" == "${loop_dev}" ]; then
        echo 1
    else
        read -r nloop_dev <<<"${loop_dev//[^0-9]/ }"
        local n
        n=$((nloop_dev-1))
        echo "/dev/loop${n}"
    fi
}

esp() {
    echo "/dev/loop0p2"
}

rootfs() {
    echo "/dev/loop0p3"
}

# Set up loop mount
loop_mount_freebsd() {
    local disk_file
    disk_file="${1}"

    r="$(mdconfig -l)"

    if ! [ "$r" == "" ]; then
        error "A loop mount exists"
        exit 1
    fi

    info "$(printf "Mounting %s" "${disk_file}")"
    mdconfig -a -t vnode -f "${disk_file}" -u 99
}

# Set up loop mount
loop_mount_linux() {
    local disk_file
    disk_file="${1}"

    if [ 1 == "$(loop_exists)" ]; then
        local loop_dev
        loop_dev="$(loop_device)"
        local mounts
        mounts="$(loop_mounts)"

        printf "\n"
        printf "Warning: A loop device already exists!\n\n"

        if [ "" != "${mounts}" ]; then
            printf "Remove loop mounts to proceed:\n"
            printf "%s\n\n" "${mounts}"
        fi

        printf "Remove existing loop devices to poceed:\n"
        printf "%s\n\n" "${loop_dev}"
        printf " # losetup -D\n\n"
        printf "Aborting..\n"
        exit 1
    fi

    modprobe loop
    if ! losetup -P -f "${disk_file}"; then
        error "$(printf "Failed to loop mount %s\n" "${disk_file}")"
        exit 1
    fi
}

loop_unmount() {
    local disk_file
    disk_file="$1"

    os="$(sys_os)"

    case "$os" in
    fedora)
        loop_unmount_linux
        ;;
    freebsd)
        loop_unmount_freebsd "${disk_file}"
        ;;
    esac
}

# FreeBSD: Tear down loop mount
loop_unmount_freebsd() {
    mdconfig -d -u "${1}"
}

# Linux: Tear down loop mount
loop_unmount_linux() {
    losetup -D
}

# Returns active loop mounts
loop_mounts() {
    local mounts
    mounts="$(mount | grep loop | awk '{print $1}')"
    echo "${mounts}"
}


install_bootloader_u_boot() {
    local img
    local img="${1}"
    local dev
    local dev="${2}"

    if dd if="${img}" of="${dev}" bs=1024 seek=8; then
        echo 0
    else
        echo 1
    fi
}

install_bootloader_efi() {
    local esp_dev
    esp_dev="${1}"
    local rootfs_dev
    rootfs_dev="${2}"
    local path
    path="${3}"
    local boot_entry_file
    boot_entry_file="${4}"
    local version
    version="${5}"

    if ! mount "${esp_dev}" "${path}"; then
        error "$(printf "Failed to install bootloader to efi sysem partition (esp)\n")"
        exit 1
    fi

    # Populate esp partition
    printf "\n"
    printf "Creating esp content at path %s..\n" "${path}"
    bootctl --esp-path="${path}" install

    # Create boot entry
    local boot_entry_title
    boot_entry_title="linux-${version}"
    create_boot_entry "/dev/sda3" "${boot_entry_file}" "${boot_entry_title}"

    printf "\n"
    ls -al "${path}"
    printf "\n"
    info "$(printf "Boot entry:\n")"
    cat "${boot_entry_file}"
    printf "\n"

    umount "${esp_dev}"
}

install_kernel() {
    local kernel
    kernel="${1}"
    local dev
    dev="${2}"
    local mnt_path
    mnt_path="${3}"
    local part_fs
    part_fs="vfat"

    if mount -t "${part_fs}" "${dev}" "${mnt_path}"; then
        cp "${kernel}" "${mnt_path}/bzimage"
    else
        error "$(printf "Failed to mount %s at %s\n" "${dev}" "${mnt_path}")"
    fi

    umount "${dev}"
}

sys_os() {
    local uname
    local os

    uname=$(uname)

    case "${uname}" in
    Darwin)
        os="macos"
        ;;
    FreeBSD)
        os="freebsd"
        ;;
    Linux)
        if ! grep '^ID=' /etc/os-release | awk -F'=' '{print $2}'\
           > /dev/null; then
            echo 1
        else
            os="$(grep '^ID=' /etc/os-release | awk -F'=' '{print $2}')"
            os="${os%$'\n'}"
        fi
        ;;
    esac

    echo "${os}"
}

sys_arch() {
    local os
    os=$(sys_os)

    local arch

    case $os in
    freebsd)
        arch=$(uname -p)
        ;;
    fedora)
        ;&
    debian)
        ;&
    ubuntu)
        arch=$(uname -m)
        ;;
    esac

    case "$arch" in
        aarch64)
        arch="arm64"
        ;;
        i686)
        arch="i386"
        ;;
    esac

    echo "$arch"
}

# Add repository for a newer version of podman
podman_add_repo() {
    info "$(printf "podman: Upgrading from repo for Ubuntu %s\n" "${ubuntu_version}")"

    sudo sh -c "echo \"deb $podman_repo_url/ /\" | tee /etc/apt/sources.list.d/devel:kubic:libcontainers:unstable.list"
    sudo sh -c "curl -fsSL $podman_repo_key_url | gpg --dearmor | tee /etc/apt/trusted.gpg.d/devel_kubic_libcontainers_unstable.gpg > /dev/null"
    sudo apt update
}

# Install podman
podman_install() {
    local os
    local cmd

    os=$(sys_os)

    case "$os" in
    debian)
        ;&
    ubuntu)
        sudo apt update -y
        sudo apt install -y podman
        ;;
    fedora)
        sudo dnf update -y
        sudo dnf install -y podman
        ;;
    esac
}

container_platform() {
    local target_arch
    target_arch="$1"

    if [ "x86_64" = "${target_arch}" ]; then
        echo "linux/amd64"
    elif [ "amd64" = "${target_arch}" ]; then
        echo "linux/amd64"
    elif [ "arm64" = "${target_arch}" ]; then
        echo "linux/arm64"
    else
        echo ""
    fi
}

freebsd_install_build_dependencies() {
    # Install build dependencies
    pkg install -y curl python
}

# src.conf / make.conf / release.conf
freebsd_fetch_build_config() {
    git clone --depth 1 "${freebsd_config_url}"
    sudo cp freebsd-config/src.conf /etc/
    sudo cp freebsd-config/make.conf /etc/
}

freebsd_fetch_src() {
    local freebsd_source_url
    freebsd_source_url="${1}"

    git clone --depth 1 "${freebsd_source_url}"
}

build_freebsd_kernel() {
    cd freebsd-src
    local version
    version="$(freebsd-version)"

    info "$(printf "Building version: %s\n" "${version}")"
    make buildkernel

    mkdir -p /tmp/build
    DESTDIR=/tmp/build make installkernel
}

build_freebsd_world() {
    local version
    version="$(freebsd-version)"

    make -j3 buildworld
    mkdir -p /tmp/build
    DESTDIR=/tmp/build make installworld
}

build_freebsd_release() {
    local version
    version="$(freebsd-version)"
    local src_path
    src_path="freebsd-src"
    # target_path is the CHROOTDIR
    # the release script builds in
    local target_path
    target_path="/release"
    local release_archive
    release_archive="freebsd-${version}.tar.xz"

    info "$(printf "Building release for version %s\n" "${version}")"
    mkdir -p "$target_path/etc"
    cp freebsd-config/release.conf "$target_path/etc"
    cp /etc/make.conf "$target_path/etc"
    cp /etc/src.conf "$target_path/etc"

    cd "${src_path}"
    sh -c "release/release.sh -c $target_path/etc"

    info "$(printf "Creating compressed archive: %s\n" "${release_archive}")"
    tar cJf "${release_archive}" "${target_path}"
}

build_nanobsd_world() {
    local version
    version="$(freebsd-version)"

    sh tools/tools/nanobsd/nanobsd.sh
}

linux_install_kernel_build_dependencies() {
    local os

    os=$(sys_os)

    case "$os" in
    debian)
        ;&
    ubuntu)
        # Install build dependencies
        apt update -y
        apt install -y linux-firmware \
                       libelf-dev \
                       intel-microcode
        ;;
    fedora)
        dnf install -y intel-gpu-firmware \
                       iwl6000-firmware \
                       linux-firmware
        ;;
    esac
}

# We also use this in a github-action
linux_build_kernel() {
    local kernel_flavour
    kernel_flavour="${1}"
    local build_use_container
    build_use_container="${2}"
    local target_arch
    target_arch="${3}"
    local kernel_version
    kernel_version="${4}"

    kernel_config_url="${kernel_config_url}/kernel-config-${kernel_flavour}"
    download "${kernel_config_url}"

    # Set to 'latest' for now, if not given
    # We'll determine the exact version later
    if [ -z "${kernel_version}" ]; then
        kernel_version="latest"
    fi

    info "$(printf "Building kernel version %s for %s with arch %s\n" "${kernel_version}" "${kernel_flavour}" "${target_arch}")"
    if [ 1 = "${build_use_container}" ]; then
        local platform
        platform=$(container_platform "$target_arch")

        if [ -z "$platform" ]; then
            error "$(printf "kernel-build: Unsupported target arch: %s\n" "${target_arch}")"
            error "kernel-build: target_arch must be amd64 or arm64\n"
        fi

        if [ "1" = "${PODMAN_USE_EXTERNAL_REPO:-1}" ]; then
            podman_add_repo
        fi

        podman_install

        mkdir -p "${PWD}/output"
        git clone --depth 1 "${kernel_src_url}" output/linux

        cd output/linux

        if [ -z "${kernel_version}" ]; then
            kernel_version="$(make kernelversion)"
        fi

        cd ../../

        mv "kernel-config-${kernel_flavour}" output/linux/.config
        podman buildx build --cap-add=SYS_PTRACE \
                            --platform="${platform}" \
                            --build-arg KERNEL_VERSION="${kernel_version}" \
                            -v "${PWD}"/output:/output \
                            -t linux-kernel-build-"${kernel_flavour}" \
                            -f Containerfile
    else
        linux_install_kernel_build_dependencies
        mv "kernel-config-${kernel_flavour}" .config
        make -j3
        mv arch/x86_64/boot/bzImage "arch/x86_64/boot/bzImage-${kernel_version}"
        sha384sum "arch/x86_64/boot/bzImage-${kernel_version}" > "arch/x86_64/boot/bzImage-${kernel_version}.sha384"
    fi
}

build_alpine() {
    local target_image_name
    target_image_name="$1"

    if [ -z "$target_image_name" ]; then
        target_image_name="${TARGET_IMAGE_NAME:-"alpine"}"
    fi

    git clone --depth 1 "$alpine_config_url"

    sudo docker run --privileged --rm multiarch/qemu-user-static --persistent yes

    docker run --rm \
               --mount type=bind,source="${PWD}"/alpine-config/input/image.sh,target=/input/image.sh \
               --mount type=bind,source="${PWD}"/alpine-config/input/modules,target=/input/modules \
               -e ARCH=armhf \
               -e DEFAULT_KERNEL_MODULES="*" \
               -e SIZE_ROOT_FS=1024M \
               -e SIZE_ROOT_PART=1024M \
               -v "${PWD}"/output:/output ghcr.io/raspi-alpine/builder

    sudo mv output/sdcard.img.gz "$target_image_name".img.gz
    sudo gunzip "$target_image_name".img.gz
    sudo xz "$target_image_name".img
    sudo sha384sum "$target_image_name".img.xz | sudo tee "$target_image_name".img.xz.sha384
}

gentoo_fetch_config() {
    local url
    url="${1}"

    git clone --depth 1 "${url}"
}

# Build a Gentoo stage3 with catalyst
# We also use this in a github-action
build_gentoo_stage3() {
    info "$(printf "Gentoo: stage3 build not implemented\n")"
}

# We also use this in a github-action
build_gentoo_stage4() {
    local flavour
    flavour="$1"
    local target_arch
    target_arch="$2"

    local platform
    platform=$(container_platform "$target_arch")

    if [ -z "$platform" ]; then
        error "$(printf "gentoo-build: Unsupported target platform: %s\n" "${target_arch}")"
        error "gentoo-build: target_arch must be amd64 or arm64\n"
        exit 1
    fi

    info "$(printf "Gentoo: Installing build dependenies for Gentoo build")"

    if [ "1" = "${PODMAN_USE_EXTERNAL_REPO:-1}" ]; then
        podman_add_repo
    fi

    podman_install

    info "$(printf "Gentoo: Building stage4")"
    mkdir -p "${PWD}"/output

    git clone --depth 1 "$gentoo_build_container_url"

    local path_containerfile
    path_containerfile="gentoo-build"
    cd "$path_containerfile"
    gentoo_fetch_config "${gentoo_config_url}"
    mkdir output

    podman buildx build --cap-add=SYS_PTRACE \
                        --platform="${platform}" \
                        --build-arg TARGETARCH="$target_arch" \
                        -v "${PWD}"/output:/output \
                        -t gentoo-stage4-"$flavour-$target_arch" \
                        -f Containerfile-"$flavour"
}

openwrt_build() {
    local flavour
    flavour="$1"

    info "$(printf "OpenWrt: Fetching config")"
    git clone --depth 1 -b dev "${openwrt_source_url}"
    cd openwrt
    git clone --depth 1 "${openwrt_config_url}"
    mv openwrt-config/openwrt-config-"$flavour" .config

    make V=s
}

install_file() {
    local src
    src="${1}"
    local target
    target="${2}"
    local mode
    mode="${3}"

    if install -m "${mode}" "${src}" "${target}"; then
        info "$(printf "%s installed to %s\n" "${src}" "${target}")"
    fi
}

install_builder() {
    local src
    src="${1}"
    local target
    target="${2}"
    local mode
    mode=755

    install_file "${src}" "${target}" "${mode}"
}

# Populate rootfs
install_rootfs() {
    mount "${1}" "${2}"
    printf "extracting stage3 to root in %s\n" "${2}"
    tar xpf stage3-*.tar.xz --xattrs-include='*.*' --numeric-owner --directory "${2}"
    printf "\n"
    ls "${2}"
    umount "${1}"
}

install_binpkgs() {
    echo "0"
}

install_fonts() {
    local path=
    path="${1}"
    local user
    user="${2}"

    mkdir -p "${path}"
    download "https://wiki.c-base.org/dokuwiki/_media/ceva-c2.ttf" \
              "${path}"
}

# Create a temporary playbook to
# provision host with given roles
ansible_write_playbook() {
    local roles_str
    roles_str="${1}"
    local file
    file="$(mktemp)"

cat <<EOF > "${file}"
---
- hosts: all
  vars:
    ansible_host_key_checking: false

  roles:
EOF

    while IFS=',' read -ra roles; do
      for i in "${roles[@]}"; do
        printf "    - %s\n" "${i}" >> "${file}"
      done
    done <<< "$roles_str"

    echo "${file}"
}

# Run playbook
ansible_run_playbook() {
    local user
    user="${1}"
    local playbook
    playbook="${2}"
    local host
    host="${3}"
    host="${host%%/*}"
    local ansible_roles_path
    ansible_roles_path="${4}"
    local cmd

    #runuser -l ansible-e2m -- /usr/bin/ansible-playbook -v -i "${host}", "${playbook}"
    chown "${user}" "${playbook}"
    # Do not ommit the comma
    su -l "${user}" -c ANSIBLE_ROLES_PATH="${ansible_roles_path}" \
                       ANSIBLE_HOST_KEY_CHECKING=False \
                       /usr/bin/ansible-playbook -v -i "${host}", "${playbook}"

    if ! ${cmd}; then
        error "Ansible: Failed during playbook execution"
    fi
}

# Provision with Ansible
ansible_provision() {
    local ansible_user
    ansible_user="${1}"
    local ansible_roles_path
    ansible_roles_path="${2}"
    local ansible_roles
    ansible_roles="${3}"
    local img
    img="${4}"
    local playbook
    playbook="$(ansible_write_playbook "${ansible_roles}")"
    local port
    port=1723

    # Start machine
    image-builder run &
    # Wait for machine to be available
    info "Ansible: Waitig for boot to finish"
    # Gentoo's stage3 does not have netcat/socat
    # Could use python
    #nc -l "${port}"
    sleep 25

    info "$(printf "Ansible: Running %s\n" "${playbook}")"
    ansible_run_playbook "${ansible_user}" \
                         "${playbook}" \
                         "${net_address}" \
                         "${ansible_roles_path}"
}

# Do what's necessary for Ansible
# to continue
provision() {
    local disk_file
    disk_file="${1}"
    local mnt_path
    mnt_path="${2}"
    local user
    user="${3}"
    local part_no
    part_no="${4}"
    local net_device
    net_device="${5}"
    local net_address
    net_address="${6}"
    local net_gateway
    net_gateway="${7}"
    local ansible_user
    ansible_user="${8}"
    local ansible_roles_path
    ansible_roles_path="${9}"
    local ansible_roles
    ansible_roles="${10}"

    local disk_part_types
    disk_part_types=$(part_types "${disk_file}")
    info "$(printf "Found %s partition(s)\n" "${#disk_part_types[@]}")"

    local part_fs
    part_fs="$(filesystem "${disk_file}" "${part_no}")"
    debug "$(printf "Detected filesystem: %s\n" "${part_fs}")"

    mount_disk_image_part_by_no "${disk_file}" \
                                "${mnt_path}" \
                                "${part_no}" \
                                "${part_fs}"

    debug "$(printf "Applying changes to partition %s\n" "${part_no}")"

    if [ -n "${ansible_user}" ]; then
        info "Creating user"
        create_user "${ansible_user}" "${mnt_path}"
    fi

    if [ -n "${SSH_PUBKEY}" ]; then
        info "Adding SSH public key"
        local uid
        uid="$(chroot_user_id "${mnt_path}" "${ansible_user}")"
        ssh_add_pubkey "${SSH_USER}" \
                       "${SSH_PUBKEY}" \
                       "${mnt_path}" \
                       "${uid}"
    fi

    info "Writing network config"
    write_net_config "${mnt_path}" \
                     "${net_device}" \
                     "${net_address}" \
                     "${net_gateway}"

    write_booted_script "${mnt_path}" "${net_host_readiness_port}"
    write_booted_service "${mnt_path}" "${net_host_address}"

    info "Writing wpa config"
    write_wpa_supplicant_config "${mnt_path}" \
                                "${WIFI_SECURITY}" \
                                "${WIFI_ESSID}" \
                                "${WIFI_PASSPHRASE}"

    info "Enabling Wifi"
    wifi_enable

    info "Adding files"
    add_files "video.mp4" "${mnt_path}"/home/"${user}"

    info "Installing fonts"
    install_fonts "${mnt_path}/home/${user}/.local/share/fonts"

    info "Configuring Sway"
    sway_configure_payload "${user}"

    info "Enabling sshd"
    service_enable "${mnt_path}" "sshd" "getty"

    if [ -n "${ansible_roles}" ]; then
        info "$(printf "Gentoo: Provisioning image with Ansible\n")"
        ansible_provision "${ansible_user}" \
                          "${ansible_roles_path}" \
                          "${ansible_roles}" \
                          "${disk_file}"
    fi

    info "$(printf "Unmounting %s\n" "${mnt_path}")"
    umount "${mnt_path}"
}

filesystem() {
    local disk_file
    disk_file="${1}"
    local part_no
    part_no="${2}"
    local dev
    local fs

    loop_mount "${disk_file}"

    local ret
    ret="$(loop_device)"

    if [ 1 == "${ret}" ]; then
        dev="/dev/loop0p${part_no}"
    else
        dev="${ret}p${part_no}"
    fi

    if lsblk -f -n -ofstype "${dev}" ; then
        # Some grace time is needed for the detection not to fail
        sleep 1
        fs="$(lsblk -f -n -ofstype "${dev}")"
        if [ -v "${fs}" ]; then
            error "$(printf "Failed to determine filesystem of %s\n" "${dev}")"
            loop_unmount ""
            exit 1
        fi
    else
        error "$(printf "Failed to determine filesystem of %s\n" "${dev}")"
        loop_unmount ""
        exit 1
    fi

    loop_unmount ""

    printf "%s" "${fs}"
}

disk_partitions() {
    local disk_file
    disk_file="${1}"
    local partitions

    partitions=$(fdisk -l "$disk_file" | grep "\.img\|^Device" | grep -v Disk)
    echo "${partitions}"
}

part_types() {
    local disk_file
    disk_file="${1}"

    local parts
    IFS=$'\n' read -r -a parts <<< "$(fdisk -l "${disk_file}" | \
                                      grep "${disk_file}" | \
                                      grep -v Disk | \
                                      awk '{ print $6 }')"
    echo "${parts[@]}"
}

alpine_create_disk() {
    local path
    path="${1}"
    local file
    file="${2}"
    local img_url
    img_url="${3}"
    local csum_url
    csum_url="${4}"
    local csum_file
    csum_file="${5}"
    local user
    user="${6}"
    local compressed_file
    compressed_file="${file}.xz"

    cd "${path}" || exit 1
    info "Alpine: Fetching pre-built image"
    download_miss "${path}" \
                  "${img_url}" \
                  "${csum_url}" \
                  "${csum_file}"

    if [ -f "${file}" ]; then
        info "Uncompressed disk image exists: Not overwriting existing one"
    else
        if [ ! -e "${compressed_file}" ];  then
            error "$(printf "Failed to decompress: File does not exist. Aborting..\n")"
            exit 1
        else
            if ! xz -d -k -f "${compressed_file}"; then
                error "$("Failed to decompress file. Aborting..\n")"
                exit 1
            fi
        fi
    fi
}

gentoo_create_disk() {
    local path
    path="${1}"
    local disk_file
    disk_file="${path}/${2}"
    local mnt_path
    mnt_path="${3}"
    local rootfs_dev
    rootfs_dev=$(rootfs)
    local esp_dev
    esp_dev=$(esp)
    local boot_entry_file
    boot_entry_file="${mnt_path}/loader/entries/linux-${kernel_version}.conf"

    local os
    os="$(sys_os)"

    if [ -z "$disk_file" ]; then
        error "$(printf "Missing disk file.\n Please provide a disk file to use.\nAborting..")"
    fi

    create_disk "${disk_file}"

    case "$os" in
    fedora)
        loop_mount_linux "${disk_file}"
        ;;
    freebsd)
        loop_mount_freebsd "${disk_file}"
        ;;
    esac

    # Create filesystems
    case "$os" in
    fedora)
        if ! mkfs.vfat "${esp_dev}"; then
            error "$(printf "Error: Failed to create filesystem\n")"
            exit 1
        fi
        if ! mkfs.xfs "${rootfs_dev}"; then
            error "$(printf "Error: Failed to create filesystem\n")"
            exit 1
        fi
        ;;
    freebsd)
        esp_dev="/dev/md99p1"
        rootfs_dev="/dev/md99p2"
        if ! newfs_msdos -F32 -c 1 "${esp_dev}"; then
            error "$(printf "Error: Failed to create filesystem\n")"
            loop_unmount_freebsd 99
            exit 1
        fi
        if ! mkfs.xfs "${rootfs_dev}"; then
            error "$(printf "Error: Failed to create filesystem\n")"
            exit 1
        fi
        ;;
    esac


    # Remove disk
    loop_unmount ""
}

write_image_to_disk() {
    local file
    file="${1}"
    local dev
    dev="${2}"
    local notify
    notify="${3}"

    file_size=$(du -h -B 1 "${file}" | cut -f1)

    if [ 1 = "$notify" ]; then
        info_n "$(printf "Writing %s to %s (%sM)\n" "${file}" "${dev}" "${file_size}")"
    else
        info "$(printf "Writing %s to %s (%sM)\n" "${file}" "${dev}" "${file_size}")"
    fi

    if dd if="${file}" of="${dev}" bs=2M status=progress; then
        echo 0
    else
        echo 1
    fi
}

ovmf_path() {
    local path
    local os

    os=$(sys_os)

    case "$os" in
    fedora)
        path="/usr/share/edk2/ovmf"
        ;;
    freebsd)
        path="/usr/local/share/uefi-firmware"
        ;;
    esac

    echo "${path}"
}

# Returns 0 if the device exists
# 1 otherwise
net_dev_exists() {
    local dev_name
    dev_name="${1}"

    local r
    r="$(ip link | grep "${dev_name}")"
    r="$(trim "$r")"

    if [ "" == "${r}" ]; then
        echo 1
    else
        echo 0
    fi
}

# Create a virtual network device
net_create_dev() {
    local dev_type
    dev_type="${1}"
    local suffix
    suffix="${2}"
    local dev_name
    local r

    case "$dev_type" in
    bridge)
        dev_name="br-${suffix}"
        r="$(net_dev_exists "${dev_name}")"
        if [ 0 == "$r" ] ; then
            return
        fi
        info "$(printf "Creating network device %s\n" "${dev_name}")"
        ip link add name "${dev_name}" type bridge
        ;;
    tap)
        dev_name="tap-${suffix}"
        r="$(net_dev_exists "${dev_name}")"
        if [ 0 == "$r" ] ; then
            return
        fi
        info "$(printf "Creating network device %s\n" "${dev_name}")"
        ip tuntap add mode tap "${dev_name}"
    esac

    ip link set dev "${dev_name}" up
}

# Show potential devices for writing an image
# e.g. USB mass storage or MMC
disk_show_storage_devices() {
    local os
    os=$(sys_os)

    case "$os" in
    freebsd)
        info "$(printf "%s\n\n" "Found the following devices:")"
        camcontrol devlist
        ;;
    fedora)
        ;;
    esac
}

service_enable() {
    local path
    path="${1}/etc/systemd/system"
    local service
    service="${2}"
    local target
    target="${3}"

cat <<EOF > "${path}/${service}.service"
[Unit]
Description=OpenSSH server daemon
After=net-config.service

[Service]
ExecStartPre=mount -o remount,rw /
ExecStartPre=sleep 2
ExecStartPre=/usr/bin/ssh-keygen -A
ExecStart=/usr/sbin/sshd -D -e
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
EOF

    ln -s -f "${path}/${service}.service" "${path}/${target}.target.wants/${service}.service"
}

# Create a dedicated bridge network
# to provision the host via Ansible
virt_setup_network() {
    local net_dev_suffix
    net_dev_suffix="${1}"
    local net_local_address
    net_local_address="${2}"

    net_create_dev "bridge" "${net_dev_suffix}"
    if ! ip addr add "${net_local_address}" dev br-"${net_dev_suffix}"; then
        debug "Failed to set IP address, might already be set"
    fi
    net_create_dev "tap" "${net_dev_suffix}"
    ip link set tap-"${net_dev_suffix}" master br-"${net_dev_suffix}"
}

run_virt_linux() {
    local disk_file
    disk_file="${1}"
    local cmd
    qemu_bin="qemu-system-x86_64"
    local fw_path
    fw_path="$(ovmf_path)"
    local fw_file
    fw_file="OVMF_CODE.fd"
    local fw_file_vars
    fw_file_vars="OVMF_VARS.fd"
    local fw
    fw="${fw_path}/${fw_file}"
    local fw_vars
    fw_vars="${fw_path}/${fw_file_vars}"
    local net_dev_suffix
    net_dev_suffix="yyy"
    local net_local_address
    net_local_address="fd62:1d79:ef52:e133::1/64"

    # We need a local writeable copy of EFI vars
    if ! cp "${fw_vars}" .; then
        error "$(printf "Failed to copy EFI vars\n")"
        error "$(printf "Failed to run virtual machine\n")"
        exit 1
    fi

    chown "${SUDO_USER}" "${fw_file_vars}"
    virt_setup_network "${net_dev_suffix}" "${net_local_address}"

    local cmd
    cmd="runuser -u ${SUDO_USER} -- \
                    ${qemu_bin} -m 2048 \
                    -machine type=q35,accel=kvm \
                    -nic tap,ifname=tap-${net_dev_suffix},script=no,downscript=no,vhost=on,model=virtio-net-pci \
                    -device virtio-vga-gl \
                    -display gtk,gl=on \
                    -drive if=pflash,format=raw,unit=0,file=${fw},readonly=on \
                    -drive if=pflash,format=raw,unit=1,file=${fw_file_vars} \
                    -drive format=raw,file=${disk_file}"

    info "$(printf "Running:\n%s\n" "$(echo -n "${cmd}" | fmt -u)")"
    $cmd
}

run_virt_freebsd() {
    local disk_file
    disk_file="${1}"
    local fw_path
    fw_path="$(ovmf_path)"
    local fw_file
    fw_file="BHYVE_UEFI_CODE.fd"
    local fw_file_vars
    fw_file_vars="BHYVE_UEFI_VARS.fd"
    local fw
    fw="${fw_path}/${fw_file}"
    local fw_vars
    fw_vars="${fw_path}/${fw_file_vars}"
    local cmd
    cmd="bhyve -m 2g \
               -l bootrom,${fw_path}/${fw_file},\
                          ${fw_vars} \
               ${disk_file}"

    info "$(printf "Running %s\n" "${cmd}")"
}

show_usage() {
    printf "\n"
    printf " image-builder\n"
    printf "\n"
    printf "  Usage:\n"
    printf "\n"
    printf "    image-builder build      TARGET\n"
    printf "    image-builder chroot     PARTITION_NUMBER\n"
    printf "    image-builder create     TARGET\n"
    printf "    image-builder install\n"
    printf "    image-builder mount      PARTITION_NUMBER\n"
    printf "    image-builder provision  PARTITION_NUMBER\n"
    printf "    image-builder write      DEVICE\n"
    printf "\n"
    printf "\n"
    printf "  TARGET            One of alpine|gentoo|freebsd\n"
    printf "  DEVICE            A raw block device e.g. /dev/sdX, /dev/mmcblk0\n"
    printf "  PARTITION_NUMBER  A partition number to work on\n"
    printf "\n"
}

main() {
    DBUS_SESSION_BUS_ADDRESS="${DBUS_SESSION_BUS_ADDRESS:-unix:path=/run/user/${UID}/bus}"
    local service_user
    service_user=iss
    local mnt_path
    mnt_path=/mnt/tmp

    # Source vars
    if [ -f ENVIRONMENT ]; then
        source ENVIRONMENT
    fi

    if [ -v "${DEBUG}" ]; then
        DEBUG=0
    fi

    if [ -v "${SEND_NOTIFICATION}" ]; then
        SEND_NOTIFICATION=0
    fi

    local build_use_container
    build_use_container="${BUILD_USE_CONTAINER:-0}"

    local net_dev
    net_dev="${NET_DEV:-"enp0s1"}"

    local net_host_address
    net_host_address="${NET_HOST_ADDRESS:-"fd62:1d79:ef52:e133::1"}"

    local net_host_readiness_port
    net_host_readiness_port="${NET_HOST_READINESS_PORT:-1723}"

    local net_address
    net_address="${NET_ADDRESS:-"fd62:1d79:ef52:e133::ffff"}"

    local net_gateway
    net_gateway="${NET_GATEWAY:-""}"

    local ansible_user
    local ansible_roles
    local ansible_roles_path
    ansible_user="${ANSIBLE_USER:-""}"

    if [ -n "${ANSIBLE_ROLES}" ]; then
        ansible_roles="${ANSIBLE_ROLES}"
        if [ -z "${ANSIBLE_ROLES_PATH}" ]; then
            error "Ansible: You need to specify the path to Ansible's roles"
            exit 1
        elif [ ! -d "${ANSIBLE_ROLES_PATH}" ]; then
            error "$(printf "Ansible: The supplied roles path does not exist: %s\n" \
                   "${ANSIBLE_ROLES_PATH}")"
            exit 1
        else
            ansible_roles_path="${ANSIBLE_ROLES_PATH}"
        fi
    fi

    # Show help
    if [ "help" == "${1}" ]; then
        show_usage
        exit 0
    fi

    # Build
    if [ "build" == "${1}" ]; then
        local build_target
        build_target="${2}"
        local target_arch
        target_arch="${3}"

        # Take target_arch from env if not provided
        # on command line or fall back to host arch
        # if none given
        if [ -z "$target_arch" ]; then
            local host_arch
            host_arch=$(sys_arch)
            target_arch="${TARGET_ARCH:-$host_arch}"
        fi

        case "$build_target" in
        alpine)
            build_alpine ""
            exit 0
            ;;
        freebsd)
            freebsd_install_build_dependencies
            freebsd_fetch_build_config
            freebsd_fetch_src "${freebsd_source_url}"
            build_freebsd_release
            #build_freebsd_kernel
            build_freebsd_world
            exit 0
            ;;
        nanobsd)
            freebsd_install_build_dependencies
            freebsd_fetch_src "${freebsd_source_url}"
            build_freebsd_kernel
            build_nanobsd_world
            exit 0
            ;;
        gentoo-containeros)
            build_gentoo_stage3
            build_gentoo_stage4 "containeros" "$target_arch"
            exit 0
            ;;
        gentoo-sway)
            build_gentoo_stage3
            build_gentoo_stage4 "sway" "$target_arch"
            exit 0
            ;;
        linux-kernel)
            target_arch="$4"

            if [ -n "${3}" ]; then
                kernel_flavour="${3}"
            else
                error "Please specify a kernel flavour\nAborting.."
                exit 1
            fi

            if [ -z "${target_arch}" ]; then
                case "$kernel_flavour" in
                    pine64)
                    target_arch="arm64"
                    ;;
                    rockpro64)
                    target_arch="arm64"
                    ;;
                    x230)
                    target_arch="amd64"
                    ;;
                    *)
                    error "Please specify a target architecture\nAborting.."
                    exit 1
                esac
            fi

            linux_build_kernel "${kernel_flavour}" \
                               "${build_use_container}" \
                               "${target_arch}"
            exit 0
            ;;
        openwrt)

            if [ -n "${3}" ]; then
                flavour="${3}"
            else
                error "Please specify a flavour to build\nAborting.."
                exit 1
            fi

            openwrt_build "${flavour}"
            exit 0
            ;;
        esac
    fi

    # Create disk image
    if [ "create" == "${1}" ]; then
        local build_target
        build_target="${2}"

        local img_path
        local img_file
        img_file="$build_target".raw

        if [ -v "${OLDPWD}" ]; then
            img_path="${OLDPWD}"
        else
            img_path="${PWD}"
        fi

        local img
        img="${img_path}/${img_file}"

        case "$build_target" in
        alma)
            # We need root privileges
            check_root

            target_img_file="alma.img"
            download "${alma_csum_url}" "${img_path}"
            local csum
            local csum_file
            csum_file="${img_path}/${alma_img_file}.sha256"
            csum=$(awk "/SHA256/ && /${alma_img_file}/" "${img_path}/${alma_csum_file}")
            echo "${csum}" > "${csum_file}"

            if [ -f "${img_path}/${alma_img_file}" ]; then
                info "$(printf "Alma: Checking checksum..\n")"
                if ! sha256sum -c "${csum_file}"; then
                    download "${alma_img_url}" "${img_path}"
                fi
            else
                download "${alma_img_url}" "${img_path}"
            fi

            info "$(printf "The image was downloaded successfully\n")"

            gentoo_create_disk  "${img_path}" \
                                "${target_img_file}" \
                                "${mnt_path}"

            printf "\n"
            disk_show_storage_devices
            printf "\n"
            info "$(printf "%s\n\n" "You can continue with")"
            info "$(printf " # image-builder write %s [DEVICE]" "${build_target}")"
            exit 0
            ;;
        alpine)
            # We need root privileges
            check_root

            alpine_create_disk "${img_path}" \
                               "${img_file}" \
                               "${alpine_img_url}" \
                               "${alpine_csum_url}" \
                               "${alpine_csum_file}" \
                               "${service_user}"

            info "$(printf "Alpine: Provisioning image\n")"

            # We need to apply changes to both partitions: A/B
            provision_image "${path}/${file}" \
                            "${mnt_path}" \
                            "${user}" \
                            2 \
                            "${net_dev}" \
                            "${net_address}" \
                            "${net_gateway}" \
                            "${ansible_user}" \
                            "${ansible_roles}"

            provision_image "${path}/${file}" \
                            "${mnt_path}" \
                            "${user}" \
                            3 \
                            "${net_dev}" \
                            "${net_address}" \
                            "${net_gateway}" \
                            "${ansible_user}" \
                            "${ansible_roles}"
            exit 0
            ;;
        gentoo)
            gentoo_create_disk  "${img_path}" \
                                "${img_file}" \
                                "${mnt_path}"

            info "Fetching kernel"
            download_miss "${path}" \
                          "${kernel_url}" \
                          "${kernel_csum_url}" \
                          "${kernel_csum_file}"


            info "Fetching stage3"
            download_miss "${path}" \
                          "${gentoo_stage3_url}" \
                          "${gentoo_stage3_csum_url}" \
                          "${gentoo_stage3_csum_file}"

            # Install EFI bootloader
            install_bootloader_efi "${esp_dev}" \
                                   "${rootfs_dev}" \
                                   "${mnt_path}" \
                                   "${boot_entry_file}" \
                                   "${kernel_version}"

            # Install files
            install_kernel "${kernel}" \
                           "${esp_dev}" \
                           "${mnt_path}" \
                           "${kernel_version}"
            install_rootfs "${rootfs_dev}" "${mnt_path}"
            install_binpkgs

            info "$(printf "Gentoo: Provisioning image\n")"

            # We need to apply changes to both partitions: A/B
            # But we do not have partition B yet (not implemented for Gentoo)
            provision "${img_path}/${img_file}" \
                      "${mnt_path}" \
                      "${user}" \
                      3 \
                      "${net_dev}" \
                      "${net_address}" \
                      "${net_gateway}" \
                      "${ansible_user}" \
                      "${ansible_roles_path}" \
                      "${ansible_roles}"

            exit 0
            ;;
        freebsd)
            freebsd_create_disk "${img_path}"
            exit 0
            ;;
        *)
            printf "\n"
            printf "You need to specify a valid target system OS\n"
            printf "  One of: alpine, gentoo, freebsd\n"
            show_usage
            exit 1
        esac
    fi

    # Install image-builder
    if [ "install" == "${1}" ]; then
        install_builder "${SCRIPT_PATH}/${SCRIPT_NAME}" \
                        "/usr/local/bin"
        exit 0
    fi

    # Mount disk image
    if [ "mount" == "${1}" ] || [ "chroot" == "${1}" ]; then
        local part_no
        part_no="${2}"

        if [ "" == "${part_no}" ]; then
            error "You need to specify the partition number to mount"
            exit 1
        fi

        # We need root privileges
        check_root

        if [ ! -e "${img}" ]; then
            error "$(printf "Can not find disk image: %s" "${img}")"
            exit 1
        fi

        local part_fs
        part_fs="$(filesystem "${img}" "${part_no}")"
        part_fs="$(echo -n "$part_fs")"

        mount_disk_image_part_by_no "${img}" \
                                    "${mnt_path}" \
                                    "${part_no}" \
                                    "${part_fs}"

        if [ "chroot" == "${1}" ]; then
            chroot "${mnt_path}" "/bin/sh"
        fi

        # Show mount content
        ls "${mnt_path}"

        exit 0
    fi

    if [ "show" == "${1}" ] ; then
        local object
        object="${2}"
        if [ -z "${object}" ]; then
            error "$(printf "Missing argument\n")"
            error "$(printf "The 'show' command needs an object to show\n")"
            exit 1
        elif [ "partitions" == "${object}" ]; then
            local partitions
            partitions="$(disk_partitions "${img}")"
            info "$(printf "%s" "${partitions}")"
            exit 0
        fi
    fi

    # Unmount
    if [ "umount" == "${1}" ]; then
        umount "${mnt_path}"
        exit 0
    fi

    # Write disk image to device
    if [ "write" == "${1}" ]; then
        # We need root privileges
        check_root

        local img
        local img="${2}"
        local img_file

        case "$img" in
        alma)
            img_file="${alma_img_file}"
            ;;
        alpine)
            img_file="alpine.img"
            ;;
        *)
            error "Please specify the image to write: One of 'alma, iss'\n"
        esac

        if ! [ -f "${img_path}/${img_file}" ]; then
            error "$(printf "A local image for '%s' does not exist" "${img}")"
            info "You need to create one first"
            printf "\n"
            info " # image-builder create alma"
            exit 1
        fi

        local device
        device="${3}"
        if [ "" == "${device}" ]; then
            printf "Missing device\n"
            printf "The 'write' command needs a device to write to\n"
            exit 1
        fi

        # test -c is needed for usb mass storage device on FreeBSD
        # -b works on Linux
        if ! [ -b "${device}" ] && ! [ -c "${device}" ]; then
            printf "Unsupported device: %s\n" "${device}"
            printf "Is a card or device inserted?\n"
            printf "Not writing image\n"
            exit 1
        fi

        local r
        r=$(write_image_to_disk "${img_path}/${img_file}" "${device}")

        if [ 0 != "$r" ]; then
            error "Failed to write image"
        fi

        if [ "pine64" = "${platform}" ]; then
            # FreeBSD Ports contains builds for Pine64/RockPro64
            local img_bootloader
            img_bootloader="/usr/local/share/u-boot/u-boot-pine64/u-boot-sunxi-with-spl.bin"
            info "Writing u-boot bootloader"
            install_bootloader_u_boot "${img_bootloader}" "${device}"
        fi

        if $SEND_NOTIFICATION; then
            if ! notify-send "image-builder: Done writing image"; then
                error "$(printf "Failed to send notification\n")"
            fi
        fi

        info "$(printf "image-builder: Done writing image\n")"

        exit 0
    fi

    # Provision disk image
    if [ "provision" == "${1}" ]; then
        # We need root privileges
        check_root

        info "$(printf "Gentoo: Provisioning image\n")"

        provision "${img_path}/${img_file}" \
                  "${mnt_path}" \
                  "${user}" \
                  3 \
                  "${net_dev}" \
                  "${net_address}" \
                  "${net_gateway}" \
                  "${ansible_user}" \
                  "${ansible_roles_path}" \
                  "${ansible_roles}"

        exit 0
    fi

    # Run disk image
    if [ "run" == "${1}" ]; then
        if [ -e "${img}" ]; then
            local os
            os=$(sys_os)

            case "$os" in
            fedora)
                run_virt_linux "${img}"
                 exit 0
                 ;;
            freebsd)
                run_virt_freebsd "${img}"
                 exit 0
                 ;;
            esac
        else
            error "$(printf "Can not find disk image: %s" "${img}")"
            exit 1
        fi
    fi

    if [ -v "${1}" ]; then
        error "$(printf "Please provide a valid verb\n")"
        show_usage
        exit 1
    fi

    error "$(printf "%s is not a valid verb\n" "${1}")"
    show_usage
    exit 1
}

main "$@"
